 МІНІСТЕРСТВО ОСВІТИ I НАУКИ УКРАЇНИ
НАЦІОНАЛЬНИЙ ТЕХНІЧНИЙ УНІВЕРСИТЕТ УКРАЇНИ
«КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ 
ІМЕНІ ІГОРЯ СІКОРСЬКОГО»
ФАКУЛЬТЕТ БІОМЕДИЧНОЇ ІНЖЕНЕРІЇ
КАФЕДРА БІОМЕДИЧНОЇ КІБЕРНЕТИКИ







КУРСОВА РОБОТА
з дисципліни «Об'єктно-орієнтоване програмування»



Варіант №24


     
     Керівник :
     доц. каф. БМК,
     к.т.н. Алхімова С.М.
     
     Виконав:
     студент гр. БС-01, ФБМІ
     Ярових Д.О.
     залікова книжка № БС-0126
     
     
     Допущено до захисту
     І ___ І _________ 2022 ___________
                                             підпис
     Захищено з оцінкою
     _________________ ___________
                оцінка                                підпис
     І ___ І _________ 2022
     
     
     Київ-2022
НАЦІОНАЛЬНИЙ ТЕХНІЧНИЙ УНІВЕРСИТЕТ УКРАЇНИ
«КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ ІМЕНІ ІГОРЯ СІКОРСЬКОГО»
Факультетбіомедичної інженерії     (назва факультету, інституту)     Кафедра  біомедичної кібернетики     (назва кафедри)     Дисципліна«Об’єктно-орієнтоване програмування»     (назва)     Курс2ГрупаБС-01Семестр4     



    ЗАВДАННЯ
    на курсовий проект (роботу) студента
Ярових Діани Олександрівни     (прізвище, ім’я, по батькові)          .
1. Тема роботи:Розробка програмного забезпечення з використанням       об'єктно-орієнтованого програмування               2. Строк здачі студентом закінченого проекту (роботи)13.05.2022          3. Вихідні дані до проекту (роботи):Варіант №24                    4. Зміст розрахунково-пояснювальної записки (перелік питань, які підлягають      розробці):1. Визначення класів та програмування меню користувача (ієрархія     ): класів програми: абстрактний клас – Військовозобов’язаний , класи-     нащадки – Капітан, військовий курсант). 2. Створення об’єктів та      використання контейнерів (тип контейнера – Двійкове дерево пошуку).      3. Організація роботи з даними через файл.      4. Пошук даних у контейнері (запит для пошуку – Вивести прізвище та      звання всіх курсантів, які є підлеглими заданого капітана).          5. Перелік графічного матеріалу (з точним зазначенням обов'язкових креслень):           діаграми класів, послідовності та об’єктів в нотації UML          6. Дата видачі завдання:18.02.2022          
КАЛЕНДАРНИЙ ПЛАН

№п/пНазва етапів курсового проекту (роботи) та питань, які мають бути розроблені відповідно до завданняТермін виконання етапуПозначки керівника 
про виконання 
завдань     1.Отримання завдання на курсову роботу18.02.2022     2.Огляд технічної літератури за темою роботи25.02.2022     3.Розробка першої частини курсової роботи (визначення класів та програмування меню користувача)11.03.2022Продовжено до 15.04.2022     4.Перший контроль за процесом виконання курсової роботи, консультація у викладача11.03.202215.04.2022     5.Розробка другої частини курсової роботи (створення об’єктів та використання контейнерів)25.03.2022Продовжено до 29.04.2022     6.Розробка третьої частини курсової роботи (робота з даними через файл)08.04.2022
Продовжено до 13.05.2022     7.Другий контроль за процесом виконання курсової роботи, консультація у викладача08.04.202213.05.2022     8.Розробка четвертої частини курсової роботи (пошук даних у контейнері)22.04.2022Продовжено до 20.05.2022     9.Оформлення пояснювальної записки13.05.2022Продовжено до 10.06.2022     10.Захист курсової роботи 26.05.202223.06.2022     

Студент	_____________________
         (підпис)

Керівник	_____________________		   Алхімова Світлана Миколаївна   
         (підпис)					 (прізвище ім'я, по батькові)

«____» _________________ 2022  р.
    АНОТАЦІЯ
     Ярових Д.О. Розробка програмного забезпечення з використанням об’єктно-орієнтованого підходу.
     Курсова робота з дисципліни «Об’єктно-орієнтоване програмування» присвячена питанню створення ієрархії класів, застосування спадкування та поліморфізму, розробки контейнера для зберігання даних множини об’єктів, які створюються користувачем. У курсовій роботі було виконана визначення класів(ієрархія класів програми: базовий клас – військовозобов’язаний, класи нащадки – капітан, військовий курсант), розроблено меню користувача, створено множину об’єктів та розроблено контейнер  для її зберігання (тип контейнера - двійкове дерево пошуку), виконано спеціалізацію даних елементів контейнера у файл та створення вмісту контейнера через десеріалізацію даних файлу, реалізовано пошук даних у контейнері(запит для пошуку – прізвища та звання всіх курсантів, які є підлеглими заданого капітана)
     Структура та обсяг роботи: курсова робота складається із вступу, трьох розділів, висновків, списку використаної літератури із трьох джерел, та п’яти додатків. Загальний обсяг курсової роботи складає 59 сторінок, основного тексту (без додатків) – 42 сторінки, ілюстрацій – 24, таблиць – 33
     

     АННОТАЦИЯ
     Яровых Д.А. Разработка программного обеспечения с использованием объектно-ориентированного подхода
     Курсовая работа по дисциплине «Объектно-ориентированное программирование» посвящена вопросу создания иерархии классов, применения наследования и полиморфизма, разработки контейнера для хранения данных множества объектов, создаваемых пользователем. В курсовой работе было выполнено определение классов (иерархия классов программы: базовый класс – военнообязанный , классы потомки – капитан, военный курсант), разработано меню пользователя, создано множество объектов и разработан контейнер для его хранения (тип контейнера – бинарное дерево поиска), выполнена специализация данных элементов контейнера в файл и создание содержимого контейнера через десериализацию данных файла, реализовано поиск данных в контейнере (запрос для поиска – фамилии и звания всех курсантов, которые в подчинении заданого капитана)
     Структура и объем работы: курсовая работа состоит из введения, трех глав, заключения, списка использованной литературы из трех источников и пяти приложений. Общий объем курсовой работы составляет 59 страниц, основного текста (без приложений) – 42 страниц, иллюстраций – 24, таблиц – 30
     

     ANNOTATION
     Yarovykh D.O. Software development using an object-oriented approach
     The course work on the subject "Object-Oriented Programming" is devoted to the creation of a hierarchy of classes, the use of inheritance and polymorphism, the development of a container for storing data on many objects created by the user. In the course work the definition of classes was performed (hierarchy of program classes: base class - conscript, descendant classes - captain, military cadet), developed user menu, created many objects and developed a container for its storage (container type - a binary search tree), specialization of data of elements of the container in the file and creation of contents of the container through deserialization of data of the file is executed, search of data in the container is realized (search query - the names and ranks of all cadets who are subordinate to a given captain)
     Structure and scope of work: the course work consists of an introduction, three chapters, conclusions, a list of references from three sources, and five appendices. The total volume of the course work is 59 pages, the main text (without appendices) - 42 pages, illustrations - 24, tables – 30
     

ЗМІСТ
ПЕРЕЛІК УМОВНИХ ПОЗНАЧЕНЬ, СИМВОЛІВ, ОДИНИЦЬ, СКОРОЧЕНЬ І ТЕРМІНІВ	9
ВСТУП	10
РОЗДІЛ 1 СПЕЦИФІКАЦІЯ ВИМОГ	11
    1.1 Функціональні вимоги	11
     1.1.1	Створення об’єкта «курсант» та додавання його до контейнера		11
     1.1.2 Створення об’єкта «капітан» та додавання його до контейнера	12
     1.1.3 Перегляд вмісту контейнера	12
     1.1.4 Вивід підлеглих заданого капітана	13
     1.1.5 Використання вбудованої інформації	14
     1.1.6 Зчитування інформації з файлу	15
     1.1.7 Завантаження інформації у файл	16
     1.1.8 Видалення даних з контейнера	16
     1.1.9 Вихід з програми	17
    1.2 Нефункціональні вимоги	18
РОЗДІЛ 2 СТРУКТУРА ТА ЛОГІКА РОБОТИ	19
    2.1 Логічна структура	19
     2.1.1 Абстрактний клас «Conscript»	19
     2.1.2 Клас «Cadet»	20
     2.1.3 Клас «Captain»	21
     2.1.4 Структура Node	22
     2.1.5 Клас «binarySearchTree»	23
     2.1.6 Клас «menu»	24
2.2 Фізична структура	25
2.3 Логіка роботи	28
РОЗДІЛ 3 ТЕСТУВАННЯ	29
    3.1 Сценарії тестування функціональних та нефункціональних вимог	29
     3.1.1 Тестування створення об’єкта «курсант»	29
     3.1.2 Тестування створення об’єкта «капітан»	29
     3.1.3 Тестування перегляду вмісту контейнера	30
     3.1.4 Тестування виводу підлеглих заданого капітана	30
     3.1.5 Тестування використання вбудованої інформації	30
     3.1.6 Тестування зчитування інформації з файлу	31
     3.1.7 Тестування завантаження інформації в файл	31
     3.1.8 Тестування видалення даних з контейнера	31
     3.1.9 Тестування виходу з програми	32
     3.1.10 Тестування вводу некоректних даних в меню	32
     3.1.11 Тестування вводу рангу, що не відповідає капітану	32
     3.1.12 Тестування інформування користувача про неможливість запису чи зчитування інформації при роботі з файлом	33
3.2 Тестові дані	34
3.3 Поетапні результати роботи	35
3.4 Модульне тестування	40
ВИСНОВКИ	41
СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ	42
ДОДАТОК А	43
ДОДАТОК Б	44
ДОДАТОК В	45
ДОДАТОК Г	58
ДОДАТОК Д	59

     
     

     ПЕРЕЛІК УМОВНИХ ПОЗНАЧЕНЬ, СИМВОЛІВ, ОДИНИЦЬ, СКОРОЧЕНЬ І ТЕРМІНІВ
     ПЗ – програмний застосунок
     КР – курсова робота
     ООП – об’єктно-орієнтоване програмування
     ОС – операційна система
     Рис. – рисунок
     Табл. – таблиця
     Продовж. – продовження
     UML – уніфікована мова моделювання
     Ідент. – ідентифікатор
     Вар. тест. – варіант тестування
     

     ВСТУП
     
     Об’єктно-орієнтоване програмування (ООП) – це методологія програмування, заснована на представленні програми у вигляді сукупності взаємодіючих об’єктів, кожен з яких є екземпляром деякого класу, а вони в свою чергу утворюють ієрархію спадкування.
     Мова С++ є однією з найпопулярніших мов програмування. Вона може похизуватися, насамперед, потужною підтримкою об’єктно-орієнтованого підходу до розробки програм. Легко реалізувати специфіку предметної області дозволяють як широкий діапазон стандартних типів даних цієї мови, так і можливості створення типів користувача. Перевагами цієї мови є: 
     - стандартизація. С++ визначається міжнародним стандартом, тому не контролюється якоюсь однією людиною.
     - швидкодія. Швидкість роботи програми на цій мові програмування не поступаються програмам на мові програмування С.
     - ефективність. Програми, розроблені на С++ використовують мінімальний рівень ресурсів таких як пам’ять, ЦПУ, енергія та інші.
     - масштабованість. На мові С++ розробляються програми для найрізноманітніших платформ та систем.
     - підтримуються різні стилі та технології програмування, включаючи традиційне процедурне програмування, ООП, узагальнене програмування та метапрограмування (шаблони, макроси).
     Метою даної курсової роботи є засвоєння набутих знань та удосконалення навичок у програмуванні при вивченні дисципліни «Об’єктно-орієнтоване програмування»
     

РОЗДІЛ 1
СПЕЦИФІКАЦІЯ ВИМОГ
     
     
1.1 Функціональні вимоги
     1.1.1 Створення об’єкта «курсант» та додавання його до контейнера
     Опис створення об’єкта «курсант» та додавання його до контейнера у табл. 1.1, діаграма використання у нотації UML наведена на рис.1.1
     
     Таблиця 1.1
     Створення об’єкта «курсант» та додавання його до контейнера
IDНазваМетаДійові особиТип варіанта використанняОпис     1Створення об’єкта «курсант»Створити об’єкта «курсант» та додати його до контейнераКористувачОсновнийСтворюється об’єкт «курсант», інформація вноситься користувачем, після чого об’єкт додається в контейнер     
Рис.1.1 Створення об’єкта «курсант»

     1.1.2 Створення об’єкта «капітан» та додавання його до контейнера
     Опис створення об’єкта «капітан» та додавання його до контейнера у табл. 1.2, діаграма використання у нотації UML наведена на рис.1.2
     
     Таблиця 1.2
     Створення об’єкта «капітан» та додавання його до контейнера
IDНазваМетаДійові особиТип варіанта використанняОпис     2Створення об’єкта «капітан»Створити об’єкта «капітан» та додати його до контейнераКористувачОсновнийСтворюється об’єкт «капітан», інформація вноситься користувачем, після чого об’єкт додається в контейнер     
Рис.1.2 Створення об’єкта «капітан»

     1.1.3 Перегляд вмісту контейнера
     Опис виведення вмісту контейнера на екран у табл. 1.3, діаграма використання у нотації UML наведена на рис.1.3
     
     
     Таблиця 1.3
     Перегляд вмісту контейнера
IDНазваМетаДійові особиТип варіанта використанняОпис     3Вивести об’єкти на екранВивести всі об’єкти контейнера на екранКористувачОсновнийВиводяться всі об’єкти та їх поля з контейнера на екран     
Рис.1.3 Перегляд вмісту контейнера

     1.1.4 Вивід підлеглих заданого капітана
     Опис виведення підлеглих курсантів заданого капітана у табл. 1.4, діаграма використання у нотації UML наведена на рис.1.4
     Таблиця 1.4
     Вивід підлеглих заданого капітана
IDНазваМетаДійові особиТип варіанта використанняОпис     4Вивід підлеглого заданого капітанаВивести всіх кадетів, що підпорядкову-ються заданому капітануКористу-вачОсновнийЗа заданим рангом відбувається пошук капітана та його перевірка на капітана, далі відбувається пошук та вивід кадетів, що підпорядковуються заданому капітану     
Рис.1.4 Вивід підлеглих заданого капітана
     
     1.1.5 Використання вбудованої інформації
     Опис використання вбудованої інформації для заповнення контейнера у табл. 1.5, діаграма використання у нотації UML наведена на рис.1.5
     
     Таблиця 1.5
     Використання вбудованої інформації
IDНазваМетаДійові особиТип варіанта використанняОпис     5Використання вбудованої інформаціїЗаповнення контейнера за допомогою вбудованої інформаціїКористувачОсновнийСтворюються об’єкти за допомогою вбудованої інформації, таким чином заповнюючи контейнер без вводу з клавіатури     
Рис.1.5 Використання вбудованої інформації

     1.1.6 Зчитування інформації з файлу
     Опис зчитування інформації з файлу табл. 1.6, діаграма використання у нотації UML наведена на рис.1.6
     
     Таблиця 1.6
     Зчитування інформації з файлу
IDНазваМетаДійові особиТип варіанта використанняОпис     6Зчитування інформації з файлуЗавантажити дані з файлу до контейнераКористувачОсновнийІнформація з файлу, назва якого вводиться з клавіатури, зчитується в контейнер послідовно     
Рис.1.6 Зчитування інформації з файлу
     1.1.7 Завантаження інформації у файл
     Опис завантаження інформації у файл у табл. 1.7, діаграма використання у нотації UML наведена на рис.1.7
     Таблиця 1.7
     Завантаження інформації у файл
IDНазваМетаДійові особиТип варіанта використанняОпис     7Завантаження інформації у файлЗавантажити дані контейнера у файл КористувачОсновнийДані контейнера завантажуються послідовно у файл Output.txt     
Рис.1.7 Завантаження інформації у файл
     1.1.8 Видалення даних з контейнера
     Опис видалення даних з контейнера у табл. 1.8, діаграма використання у нотації UML наведена на рис.1.8
     Таблиця 1.8
     Видалення даних з контейнера
IDНазваМетаДійові особиТип варіанта використанняОпис     8Видалення даних з контейнераВидалити об’єкти з контейнераКористувачОсновнийВидаляються об’єкти з контейнера     
Рис.1.8 Видалення даних з контейнера
     
     1.1.9 Вихід з програми
     Опис завершення роботи у табл. 1.9, діаграма використання у нотації UML наведена на рис.1.9
     Таблиця 1.9
     Вихід з програми
IDНазваМетаДійові особиТип варіанта використанняОпис     9Вихід з програмиЗавершення роботи пзКористувачОсновнийЗавершується робота програми     
Рис.1.9 Вихід з програми
     

1.2 Нефункціональні вимоги
     З перевірених джерел можна сказати, що «нефункціональні вимоги описують характеристики системи та її оточення, а не поведінку системи. <….> Отже, нефункціональні вимоги не визначають поведінку системи, але описують атрибути системи або атрибути системного оточення» [1]
     ID 10: Введення некоректних даних при роботі з меню. У випадку, якщо користувач ввів невірне значення йому буде виведена помилка та запропоновано скористатись меню ще раз, поки не буде введено вірне число.
     ID 11: У разі введення рангу, що не відповідає капітану у пункті «4» меню, користувач отримує повідомлення про те, що заданий ранг не відповідає капітану
     ID 12: При неможливості відкриття файлу для зчитування чи запису даних користувач буде повідомлений про помилку виводом відповідної інформації на екран.
     

РОЗДІЛ 2
СТРУКТУРА ТА ЛОГІКА РОБОТИ
     
     
     2.1 Логічна структура
     Діаграма класів представлена на окремому аркуші (Див. Додаток А)
     
     2.1.1 Абстрактний клас «Conscript»
     Клас «Conscript» є абстрактним базовим класом, що описує військовозобов’язаного. Поля захищеного інтерфейсу описані у табл. 2.1.1, а методи відкритого інтерфейсу у табл. 2.1.2
     
     Таблиця 2.1.1
     Поля захищеного інтерфейсу класу «Conscript»
№ з/пНазваТипПризначення     1_idintID     2_surnamestringПрізвище     3_namestringІм’я     4_rankintРанг     5_ageintВік          
     Таблиця 2.1.2
     Методи відкритого інтерфейсу класу «Conscript»
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     1getId()      -IDПовертає id об’єкта     2Conscript()      --Конструктор за замовчуванням (метод класу, який виконується при створенні об’єкту)          
     
     Продовження таблиці 2.1.2
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     3Conscript(string surname, string name, int rank, int age)Прізвище, ім’я, ранг та вік-Конструктор з параметрами, встановлює поля класу     4const string& getSurname() const;-ПрізвищеПовертає прізвище об’єкта     5void setSurname(const string& surname);Прізвище-Встановлює поле «прізвище» переданим значенням     6const string& getName() const;-Ім’яПовертає ім’я об’єкта     7void setName(const string& name);Ім’я-Встановлює поле «Ім’я» переданим значенням     8int getRank() const;-РангПовертає ранг об’єкта     9void setRank(int rank);Ранг-Встановлює поле «Ранг» переданим значенням     10int getAge() const;-ВікПовертає вік об’єкта     11void setAge(int age);Вік-Встановлює поле «Вік» переданим значенням     12virtual void show()const;--Віртуальний метод виводу інформації на консоль     13virtual ~Conscript()--Віртуальний деструктор (метод класу, який виконується при знищенні об’єкту та зазвичай очищає пам’ять від усіх пов’язаних з класом даних)     14friend ostream& operator<<(ostream& os, const Conscript& conscript)Посилання на потік, посилання на об’єкт класуПотік виводуОператор перевантаження операції виводу на екран      15friend istream& operator>>(istream& is, Conscript& data);Посилання на потік, посилання на об’єкт класуПотік вводуОператор перевантаження операції вводу з клавіатури          
     2.1.2 Клас «Cadet»
     Клас «Cadet» це клас-нащадок класу «Conscript», що описує військового курсанта. Поля закритого інтерфейсу описані у табл. 2.1.3, а методи відкритого інтерфейсу у табл. 2.1.4
     Таблиця 2.1.3
     Поля закритого інтерфейсу класу «Cadet»
№ з/пНазваТипПризначення     1_subordinatestringПідпорядкування          
     Таблиця 2.1.4
     Методи відкритого інтерфейсу класу «Cadet»
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     1const string& getSubordinate() const
-ПідпорядкуванняПовертає підпорядкування кадета певному полку     2void setSubordinate(const string& subordinate)Підпорядкування-Встановлює поле «підпорядкування» переданим знаяенням     3Cadet(const string& surname, const string& name, int rank, int age, string subordinate)Прізвище, ім’я, ранг, вік, підпорядкування-Конструктор з параметрами     4Cadet()--Конструктор за замовчуванням (метод класу, який виконується при створенні об’єкту)     5void show() const--Метод виводу інформації на екран     6friend ostream& operator<<(ostream& os, const Cadet& cadet)Посилання на потік, посилання на об’єкт класу CadetПотік виводуПеревантаження операції виводу інформації на екран     7friend istream& operator>>(istream& is, Cadet& data);Посилання на потік, посилання на об’єкт класу CadetПотік вводуПеревантаження операції вводу інформації з клавіатури     8~Cadet()--Деструктор          
     2.1.3 Клас «Captain»
     Клас «Captain» є класом-нащадком класу «Conscript», що описує капітана. Поля закритого інтерфейсу описані у табл. 2.1.5, а методи відкритого інтерфейсу у табл. 2.1.6
     Таблиця 2.1.5
     Поля закритого інтерфейсу класу «Captain»
№ з/пНазваТипПризначення     1experienceintДосвід          
     Таблиця 2.1.6
     Методи відкритого інтерфейсу класу «Captain»
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     1Captain()--Конструктор за замовчуванням (метод класу, який виконується при створенні об’єкту)     2Captain(const string& surname, const string& name, int rank, int age, int experience)Прізвище, ім'я, ранг, вік, досвід-Конструктор з параметрами     3friend ostream& operator<<(ostream& os, const Captain& captain)Посилання на потік, посилання на об'єкт класу CaptainПотік виводуПеревантаження операції виводу інформації на екран     4friend istream& operator>>(istream& is, Captain& data)Посилання на потік, посилання на об'єкт класу CaptainПотік вводуПеревантаження операції вводу інформації з клавіатури     5void show() const override--Метод виводу інформації на екран     6~Captain() override--Деструктор за замовчуванням          
     2.1.4 Структура Node
     Дана структура описує контейнер типу бінарне дерево та призначена для використання у класі «binarySearchTree». Опис структури наведений у таблиці 2.1.7
     
     
     Таблиця 2.1.7
     Поля відкритого інтерфейсу структури «Node»
№ з/пНазваТипПризначення     1leftNode*Дочірній вузол бінарного дерева     2rightNode*Дочірній вузол бінарного дерева     3dataConscript*Дані вузла          
     2.1.5 Клас «binarySearchTree»
     Цей клас є контейнером типу бінарне дерево пошуку для зберігання даних. Поля закритого інтерфейсу описані у табл.2.1.8 а методи відкритого інтерфейсу у табл. 2.1.9
     Таблиця 2.1.8
     Поля закритого інтерфейсу класу «binarySearchTree»
№ з/пНазваТипПризначення     1rootNode*Корінь бінарного дерева          Таблиця 2.1.9
     Методи відкритого інтерфейсу класу «binarySearchTree»
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     1Node* RecursiveSearch(Node* root, int rank)Корінь бінарного дерева, ранг-Метод рекурсивного пошуку вузла за рангом     2void RecursiveInsert(Node*& node, Conscript* data)Вузол структури, дані вузла-Метод заповнення дерева переданими значеннями     3void PrintInorder(Node* node)Вузол структури-Метод виводу на екран вузлів бінарного дерева     4void PrintInorderCadet(Node* node)Вузол структури-Метод виводу на екран курсантів певного капітана     5void CleanTree(Node* node)Вузол структури-Метод очищення бінарного дерева     6void PrintTree()--Метод виводу на екран всього бінарного дерева          Продовження таблиці 2.1.9
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     7void Insert(Conscript* data)Дані вузла-Метод створення нових вузлів дерева     8void PrintChildrenByRank(int rank)Ранг-Метод пошуку та виводу курсантів, що належать заданому капітану     9Conscript* Search(int rank)РангДані вузлаМетод пошуку необхідних вузлів     10void LoadFromFile()--Метод зчитування з файлу     11void LoadIntoFile()--Метод запису у файл     12void LoadIntoFileRecursively(Node* nextNode, ofstream& out)Посилання на потік, посилання на вузол-Метод рекурсивного запису бінарного дерева у файл     13virtual ~BinarySearchTree()--Деструктор за замовчуванням          
     2.1.6 Клас «menu»
     Цей клас описує методи, що реалізовують меню користувача. Опис методів відкритого типу у табл. 2.1.10
     Таблиця 2.1.10
     Методи відкритого інтерфейсу класу «menu»
№ з/пСигнатураВхідні параметриПовернене значенняПризначення     1static char PrintMenu()--Метод виводу на екран меню     2static void MockTreeSetup(BinarySearchTree* bst)Дані для заповнення вузла дерева-Метод заповнення бінарного дерева вбудованою інформацією     3static Cadet* CreateCadet()--Метод створення курсанта     4static Captain* CreateCaptain()--Метод створення капітна     5static void Dialog();--Метод запуску виконання операцій меню          

     2.2 Фізична структура
     Опис розподілу класів, змінних, функцій та інших компонентних структур наведено у табл. 2.2.1
     Таблиця 2.2.1
     Опис фізичної структури
№ з/пНазва файлуКомпонентиЗовнішні компоненти                 назваописназваопис     1menu.hMenuВизначення класу menubinarySearchTree.hЗаголовний файл     Conscript.hЗаголовний файл     Cadet.hЗаголовний файл     Captain.hЗаголовний файл     2menu.cppPrintMenuРеалізація меню користувачаmenu.hЗаголовний файл     MockTreeSetup     CreateCadet     CreateCaptain     Dialog     3conscript.hConscriptВизначенная класу військово-зобов’язаногоiostreamРобота з потоками     stringРобота з рядками     4conscript.cppcurrentIdРеалізація методів абстрактного класуconscript.hЗаголовний файл     show     Conscript     getSurname     setSurname     getName     setName     getRang     setRang     getAge     setAge     getId     operator<<     operator>>     ~Conscript          
     Продовження таблиці 2.2.1
№ з/пНазва файлуКомпонентиЗовнішні компоненти                 назваописназваопис     5cadet.hCadetВизначення класу військового курсантаiostreamРобота з потоками     stringРобота з рядками     conscript.hЗаголовний файл     6cadet.cppshowРеалізація методів класу військового курсантаcadet.hЗаголовний файл     CadetiostreamРобота з потоками     getSubordinate     setSubordinatestringРобота з рядками     Operator<<conscript.hЗаголовний файл     Operator>>     7captain.hCaptainВизначення класу капітанаostreamРобота з потоками     istreamРобота з потоками     conscript.hЗаголовний файл     stringРобота з рядками     8captain.cppCaptainРеалізація методів класу капітанаcaptain.hЗаголовний файл     showiostreamРобота з потоками     Operator<<stringРобота з рядками     Operator>>     9binarySearchTree.hBinarySearchTreeВизначення класу контейнера типу бінарне дерево пошукуconscript.hЗаголовний файл     10binarySearchTree.cppRecursiveSearchРеалізація методів класу контейнераfstreamРобота з файлами     Search     InsertbinarySearchTree.hЗаголовний файл     RecursiveInsert     PrintInorder          
     Продовження таблиці 2.2.1
№ з/пНазва файлуКомпонентиЗовнішні компоненти                 назваописназваопис     10binarySearchTree.cppPrintTreeРеалізація методів класу контейнераcaptain.hЗаголовний файл     PrintInorderCadet     PrintChildrenByRank     ~BinarySearchTree     CleanTreecadet.hЗаголовний файл     LoadFromFile     LoadIntoFile     LoadIntoFileRecursively     11coursework.cppmainЗапуск меню користувачаiostreamРобота з потоками     menu.hЗаголовний файл          
     

     2.3 Логіка роботи
     Діаграма послідовності знаходиться на окремому аркуші (див. Додаток Б)
     

 РОЗДІЛ 3
ТЕСТУВАННЯ
     
     
     3.1 Сценарії тестування функціональних та нефункціональних вимог
     
     3.1.1 Тестування створення об’єкта «курсант»
     Таблиця 3.1
     Сценарій тестування створення об’єкта «курсант»
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_1Створення об’єкта «курсант»1Запуск програми, запуск меню користувача, вибір користувачаЗапускаємо програму, обираємо необхідний пункт в меню, вводимо «1», послідовно заповнюємо поляСтворення та додавання об'єкта «курсант» у контейнерЗапис введеної інформації у контейнер, вивід меню у консоль          
     3.1.2 Тестування створення об’єкта «капітан»
     Таблиця 3.2
     Сценарій тестування створення об’єкта «капітан»
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_2Створення об’єкта «капітан»2Запуск програми, запуск меню користувача, вибір користувачаОбираємо необхідний пункт в меню, вводимо «2», послідовно заповнюємо поляСтворення та додавання об'єкта «капітан» у контейнерЗапис введеної інформації у контейнер, вивід меню у консоль          
     3.1.3 Тестування перегляду вмісту контейнера
     Таблиця 3.3
     Сценарій тестування перегляду вмісту контейнера
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_3Перегляд вмісту контейнера3Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню користувача «3»Виведення на екран інформація, що міститься у контейнеріВивід меню у консоль          
     3.1.4 Тестування виводу підлеглих заданого капітана
     Таблиця 3.4
     Сценарій тестування виводу підлеглих заданого капітана
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_4Вивід підлеглих заданого капітана4Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню користувача «4», вводимо ранг капітана, підлеглих якого ми хочемо знайтиПеревірка рангу чи відповідає заданий ранг капітану, виведення інформації про підлеглих заданого капітанаВивід меню у консоль          3.1.5 Тестування використання вбудованої інформації
     Таблиця 3.5
     Сценарій тестування використання вбудованої інформації
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_5Використання вбудованої інформації5Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню  користувача «5»Заповнення контейнера вбудованою інформацією, отримання повідомлення про успішне заповненняВивід меню у консоль          3.1.6 Тестування зчитування інформації з файлу
     Таблиця 3.6
     Сценарій тестування зчитування інформації з файлу
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_6Зчитування інформації з файлу6Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню «6», вводимо назву файлу, з якого будемо зчитувати даніЗаповнення контейнера зчитанними даними, отримання повідомлення про успішне зчитуванняВивід меню у консоль          
     3.1.7 Тестування завантаження інформації в файл
     Таблиця 3.7
     Сценарій тестування завантаження інформації в файл
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_7Завантаження інформації в файл7Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню користувача «5»Запис інформації у файл output.txt, отримання інформації про успішне завантаженняВивід меню у консоль          
     3.1.8 Тестування видалення даних з контейнера
     Таблиця 3.8
     Сценарій тестування видалення даних з контейнера
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_8Видалення даних з контейнера8Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню «8»Очищення контейнера, отримання повідомлення про очищення контейнераВивід меню у консоль          
     3.1.9 Тестування виходу з програми
     Таблиця 3.9
     Сценарій тестування виходу з програми
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_9Вихід з програми9Запуск програми, запуск меню користувача, вибір користувачаВводимо у меню користувача «9»Завершення роботи програми-          
     3.1.10 Тестування вводу некоректних даних в меню
     Таблиця 3.10
     Сценарій тестування вводу некоректних даних в меню
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_10Ввід некоректних даних в меню10Запуск програми, запуск меню користувача, вибір користувачаВводимо некоректне значення в менюВивід повідомлення про ще одну спробуВивід меню у консоль          
     3.1.11 Тестування вводу рангу, що не відповідає капітану
     Таблиця 3.11
     Сценарій тестування вводу рангу, що не відповідає капітану
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_11Ввід рангу, що не відповідає капітану11Запуск програми, запуск меню користувача, вибір користувачаВводимо ранг, що не відповідає капітнануВивід повідомлення, що заданий ранг не відповідає капітнануВивід меню у консоль          
     
     3.1.12 Тестування інформування користувача про неможливість запису чи зчитування інформації при роботі з файлом
     Таблиця 3.12
     Сценарій тестування інформування користувача про неможливість запису чи зчитування інформації при роботі з файлом
IDНазваID вимогиПередумоваТестові крокиОчікуваний результатПісляумова     Test_12Інформування користувача про помилку роботи з файлом12Запуск програми, запуск меню користувача, вибір користувачаВводимо назву файлу, якого не існує, або записуємо у файл, якого не існуєВивід повідомлення про помилку роботи з файломВивід меню у консоль          

     3.2 Тестові дані
     
     Діаграма об’єктів, що використовувались для тестування, наведена у нотації UML на окремому аркуші (Див. Додаток Г)
     На рис. 3.2 наведена копія з екрану вмісту файлу, в якому зберігаються тестові дані
       
     Рис. 3.2 Вміст тестового файлу
     

     3.3 Поетапні результати роботи
     
     На рисунках 3.3.1-3.3.16 наведено результати поетапного тестування, що описано у пункті 3.1
             
Рис.3.3.1 Створення об’єкта «курсант»      Рис.3.3.2 Створення об’єкта «капітан»

Рис.3.3.3 Перегляд вмісту контейнера

Рис. 3.3.4 Вивід підлеглих заданого капітана
     
     Рис.3.3.5 Використання вбудованої інформації
     
     Рис.3.3.6 Зчитування інформації з файлу
     
     Рис. 3.3.7 Запис інформації у файл Output.txt
     
     Рис.3.3.8 Видалення даних з контейнера
     
     Рис.3.3.9 Вихід з програми
     
     Рис.3.3.10 Ввід некоректних даних у меню
     
     Рис.3.3.11 Введення рангу не капітана
     
     Рис.3.3.12 Повідомлення про помилку відкриття файла
     

     3.4 Модульне тестування
     
     
     Рис.3.4.1 Результат виконання unit-тестів
     
     Рис.3.4.2 Результат виконання unit-тестів
     

    ВИСНОВКИ
     
     У цій курсовій роботі було розроблено програмний додаток, який реалізував у собі абстрактний клас «Військовозобов’язаний» та два класи-нащадки «Капітан» та «Військовий курсант», меню та діалог з користувачем, що складається з 9 пунктів та обробки помилок, а також контейнер у вигляді двійкового дерева пошуку.
     На першому етапі розробки було створено абстрактний клас, класи-нащадки та меню користувача. На другому етапі було розроблено можливість створення об’єктів та роботу з контейнером. На цьому етапі я розробила контейнер у вигляді двійкового дерева пошуку. Об’єкти розташовуються за рангом кожного капітана та курсанта.
     На третьому етапі розробки програмного додатку була додана можливість роботи з файлами, на четвертому – пошук даних у контейнері.
     Також було реалізовано архітектуру програмного додатку від ФВ до UML діаграм з логікою роботи. І, звичайно, було розроблено сценарії тестування для ручного тестування програмного додатку через меню користувача.
     Результатом даної роботи є програмний додаток, написаний мовою С++, розроблений з урахуванням принципів об’єктно-орієнтованого програмування. В ході роботи було реалізовано усі визначені вимоги.
     
     

    СПИСОК ВИКОРИСТАНИХ ДЖЕРЕЛ
     
1. Алхімова С. М. Об’єктно-орієнтоване програмування : підручник. У 2-х ч. Ч. 2. Об’єктно-орієнтований підхід до розробки програмного забезпечення / С. М. Алхімова. – К. : КПІ ім. Ігоря Сікорського, Вид-во «Політехніка», 2019. – 192 с.
2. Алхімова С. М. Алгоритмізація та програмування мовою високого рівня С++ : комп’ютерний практикум / С. М. Алхімова. – К. : КПІ ім. Ігоря Сікорського, Вид-во «Політехніка», 2018. – 156 с.
3. Кормен, Т. X. Алгоритми: построение и анализ / Т. X. Кормен, Ч. И. Лейзерсон, Р. Л. Ривест, К. Штайн; пер. с англ. И. Красиков. - М.: Вильямс, 2016. -1328 с.
     

    ДОДАТОК А

Рис. 1 Діаграма класів у нотації UML
     

    ДОДАТОК Б

Рис.2 Діаграма послідовностей у нотації UML
     

    ДОДАТОК В
     Coursework.cpp
#include <iostream>
#include "menu.h"
//тут починається робота програми
int main() {
    Menu::Dialog();
    return 0;
      }
     Menu.h
#ifndef _MENU_H
#define _MENU_H
#include "binarySearchTree.h"
#include "conscript.h"
#include "cadet.h"
#include "captain.h"
//Визначення класу меню
class Menu {
public:
    static char PrintMenu();

    static void MockTreeSetup(BinarySearchTree* bst); //Метод використання вбудованої інформації

    static Cadet* CreateCadet();
    static Captain* CreateCaptain();
    static void Dialog(); //Метод запуску діалогу з користувачем

};

      #endif //_MENU_H
     Menu.cpp
#include "menu.h"
using namespace std;
//Реалізація меню
char Menu::PrintMenu() {
    int variant;
    cout << endl;
    cout << "----------------MENU----------------" << endl;
    cout << "1. Add new cadet" << endl;
    cout << "2. Add new captain" << endl;
    cout << "3. Print all tree" << endl;
    cout << "4. Print captain subordinates by rank" << endl;
    cout << "5. Use mock data" << endl;
    cout << "6. Load from file" << endl;
    cout << "7. Load in file" << endl;
    cout << "8. Clean binary tree" << endl;
    cout << "9. Exit program" << endl;
    cout << "Choose please: ";
    cin >> variant;
    cout << "\r" << endl;
    return variant;
}
/*Для полегшення роботи з деревом я створила функцію, що містить вбудовану інформацію для кожного об'єкта.
Оскільки для перевірки функціонування пошуку по дереву недостатньо 1-2 об'єктів*/
void Menu::MockTreeSetup(BinarySearchTree* bst) {
    bst->Insert(new Captain("Sydorov", "Sidr", 15, 30, 4));
    bst->Insert(new Cadet("Ivanov", "Ivan", 8, 22, "2_polk"));
    bst->Insert(new Captain("Petrov", "Petro", 45, 55, 25));
    bst->Insert(new Cadet("Nykolayv", "Nykolay", 1, 21, "2_polk"));
    bst->Insert(new Cadet("Aloxin", "Alixey", 10, 20, "2_polk"));
    bst->Insert(new Cadet("Alexandrov", "Alexandr", 30, 35, "1_polk"));
    bst->Insert(new Cadet("Nikitin", "Nikita", 55, 42, "1_polk"));
    bst->Insert(new Captain("Pavlov", "Pavlo", 31, 43, 14));
    bst->Insert(new Cadet("Valerych", "Valeriy", 13, 28, "3_polk"));
    bst->Insert(new Cadet("Illich", "Illiya", 24, 29, "3_polk"));
    cout << "Information uploaded successfully!" << endl;
}

Cadet* Menu::CreateCadet() {
    string firstName;
    string lastName;
    int rank;
    int age;
    string subordinate;
    cout << "First Name:" << endl;
    cin >> firstName;
    cout << "Last Name:" << endl;
    cin >> lastName;
    cout << "Rank:" << endl;
    cin >> rank;
    cout << "Age:" << endl;
    cin >> age;
    cout << "Subordinate:" << endl;
    cin >> subordinate;
    return new Cadet(lastName, firstName, rank, age, subordinate);
}

Captain* Menu::CreateCaptain() {
    string firstName;
    string lastName;
    int rank;
    int age;
    int experience;
    cout << "First Name:" << endl;
    cin >> firstName;
    cout << "Last Name:" << endl;
    cin >> lastName;
    cout << "Rank:" << endl;
    cin >> rank;
    cout << "Age:" << endl;
    cin >> age;
    cout << "Years of experience:" << endl;
    cin >> experience;
    return new Captain(lastName, firstName, rank, age, experience);
}

void Menu::Dialog() {
    int variant = 0;
    auto* tree = new BinarySearchTree();
    do {
        variant = PrintMenu();
        switch (variant) 
        {
        case 1:
            tree->Insert(CreateCadet());
            break;
        case 2:
            tree->Insert(CreateCaptain());
            break;
        case 3:
            tree->PrintTree();
            break;
        case 4:
            int rank;
            cout << "Input captain rank: ";
            cin >> rank;
            tree->PrintChildrenByRank(rank);
            break;
        case 5:
            MockTreeSetup(tree);
            break;
        case 6:
            tree->LoadFromFile();
            break;
        case 7:
            tree->LoadIntoFile();
            break;
        case 8:
            delete tree;
            tree = new BinarySearchTree();
            cout << "Tree is clean!" << endl;
            break;
        case 9:
            delete tree;
            cout << "Thank you!" << endl;
            system("pause");
            break;
        default:
            cout << "Try again!" << endl;
            variant = PrintMenu();
            break;
        }
    } while (variant != 9);
      }
     Conscript.h
#ifndef _CONSCRIPT_H
#define _CONSCRIPT_H
#include "iostream"
#include "string"
using namespace std;
//Визначення абстрактного класу Військовозобов'язаного
class Conscript {
    static int currentId;
public:
    int getId() const; //Метод присвоювання кожному об'єкту ID
protected:
    int _id;
    string _surname;
    string _name;
    int _rank;
    int _age;
public:
    Conscript(); //Конструктор 
    Conscript(string surname, string name, int rank, int age); //Конструктор з параметрами

    const string& getSurname() const;
    void setSurname(const string& surname);
    const string& getName() const;
    void setName(const string& name);                        //Стандартні set i get методи
    int getRank() const;
    void setRank(int rank);
    int getAge() const;
    void setAge(int age);

    virtual void show()const;
    virtual ~Conscript() = 0; //Віртуальний деструктор

    friend ostream& operator<<(ostream& os, const Conscript& conscript); 
    friend istream& operator>>(istream& is, Conscript& data);                  // Оператори перевантаження вводу та виводу інформації
};

      #endif //_CONSCRIPT_H
     Conscript.cpp
#include "conscript.h"
using namespace std;
//Реалізація абстрактного класу
int Conscript::currentId;
void Conscript::show() const 
{
    cout << "ID: " << getId() << std::endl;
    cout << "Surname: " << getSurname() << std::endl;
    cout << "Name: " << getName() << std::endl;
    cout << "Rank: " << getRank() << std::endl;
    cout << "Age: " << getAge() << std::endl;
}

Conscript::Conscript() : _id(currentId++), _surname(""), _name(""), _rank(0), _age(0) {}

const string& Conscript::getSurname() const 
{
    return _surname;
}

void Conscript::setSurname(const string& surname) {
    _surname = surname;
}

const string& Conscript::getName() const {
    return _name;
}

void Conscript::setName(const string& name) {
    _name = name;
}

int Conscript::getRank() const {
    return _rank;
}

void Conscript::setRank(int rank) {
    _rank = rank;
}

int Conscript::getAge() const {
    return _age;
}

void Conscript::setAge(int age) {
    _age = age;
}

Conscript::Conscript(string surname, string name, int rank, int age) : _id(currentId++), _surname(move(surname)),
    _name(std::move(name)),
    _rank(rank),
    _age(age) {}

int Conscript::getId() const {
    return _id;
}

ostream& operator<<(ostream& os, const Conscript& conscript) {
    os << conscript._id << endl << conscript._surname << endl << conscript._name << endl
        << conscript._rank << endl << conscript._age << endl;
    return os;
}

istream& operator>>(istream& is, Conscript& data) {
    is >> data._id >> data._surname >> data._name >> data._rank >> data._age;
    return is;
}

      Conscript::~Conscript() = default;
     Cadet.h
#ifndef _CADET_H
#define _CADET_H
#include "iostream"
#include "string"
#include "conscript.h"
using namespace std;
//Визначення класу військового курсанта
class Cadet : public Conscript { 
private:
    string _subordinate;
public:
    const string& getSubordinate() const;

    void setSubordinate(const string& subordinate);

    Cadet(const string& surname, const string& name, int rank, int age, string subordinate);

    Cadet();

    void show() const;

    friend ostream& operator<<(ostream& os, const Cadet& cadet);
    friend istream& operator>>(istream& is, Cadet& data);
    ~Cadet() = default;

};
#endif //_CADET_H
     
     Cadet.cpp
#include "cadet.h"
#include "iostream"
#include "string"
#include "conscript.h"
using namespace std;
//Реалізація класу курсанта
void Cadet::show() const {
    Conscript::show();
    cout << "Subordinate: " << _subordinate << endl;
}

Cadet::Cadet(const string& surname, const string& name, int rank, int age, string subordinate)
    : Conscript(surname, name, rank, age), _subordinate(move(subordinate)) {}

const string& Cadet::getSubordinate() const {
    return _subordinate;
}

void Cadet::setSubordinate(const string& subordinate) {
    _subordinate = subordinate;
}

Cadet::Cadet() : Conscript("", "", 0, 0), _subordinate("") {}

ostream& operator<<(ostream& os, const Cadet& cadet) {
    os << static_cast<const Conscript&>(cadet) << cadet._subordinate << endl;
    return os;
}

istream& operator>>(istream& is, Cadet& data) {
    is >> static_cast<Conscript&>(data) >> data._subordinate;
    return is;
}
     
     Captain.h
#ifndef _CAPTAIN_H
#define _CAPTAIN_H
#include <ostream>
#include "conscript.h"
#include "istream"
#include "string"
using namespace std;

//Визначення класу капітана
class Captain : public Conscript {
private:
    int experience;
public:
    Captain();
    Captain(const string& surname, const string& name, int rank, int age, int experience);

    friend ostream& operator<<(ostream& os, const Captain& captain);
    friend istream& operator>>(istream& is, Captain& data);
public:
    void show() const override;
    ~Captain() override = default;
};
      #endif //_CAPTAIN_H
     Captain.cpp
#include "captain.h"
#include "iostream"
#include "string"
using namespace std;
//Реалізація класу капітана
Captain::Captain(const string& surname, const string& name, int rank, int age, int experience)
    : Conscript(surname, name, rank, age), experience(experience) {}

Captain::Captain() : Conscript("", "", 0, 0), experience(0) {}

void Captain::show() const {
    Conscript::show();
    cout << "Experience: " << this->experience << " years\n";
}

ostream& operator<<(ostream& os, const Captain& captain) {
    os << static_cast<const Conscript&>(captain) << captain.experience << endl;
    return os;
}

istream& operator>>(istream& is, Captain& data) {
    is >> static_cast<Conscript&>(data) >> data.experience;
    return is;
}
     
     BinarySearchTree.h
#ifndef _BINARYSEARCHTREE_H
#define _BINARYSEARCHTREE_H
#include "conscript.h"
//Структура для реалізації бінарного дерева
struct Node {
public:
    struct Node* left = nullptr;      
    struct Node* right = nullptr;
    Node();
    Node(Conscript* data);
    Conscript* data = nullptr;
    ~Node();
};
//Визначення класу контейнера
class BinarySearchTree {
private:
    Node* root;  //Корінь дерева, що встановлюється першим і вже від нього йде розмежування
public:
    Node* RecursiveSearch(Node* root, int rank);
    void RecursiveInsert(Node*& node, Conscript* data);
    void PrintInorder(Node* node);
    void PrintInorderCadet(Node* node);
    void CleanTree(Node* node);
    void PrintTree();
    void Insert(Conscript* data);
    void PrintChildrenByRank(int rank);
    Conscript* Search(int rank);
    void LoadFromFile();
    void LoadIntoFile();
    void LoadIntoFileRecursively(Node* nextNode, ofstream& out);
    virtual ~BinarySearchTree();
};
      #endif //_BINARYSEARCHTREE_H
     BinarySearchTree.cpp
#include <fstream>
#include "binarySearchTree.h"
#include "captain.h"
#include "cadet.h"
using namespace std;
//Реалізація бінарного дерева пошуку
Node::~Node() {
    delete data;
}

Node::Node(Conscript* data) {
    this->data = data;
}

Node::Node() = default;

Node* BinarySearchTree::RecursiveSearch(Node* root, int rank) {
    if (root == nullptr || root->data->getRank() == rank)
        return root;
    if (root->data->getRank() < rank)
        return RecursiveSearch(root->right, rank);
    return RecursiveSearch(root->left, rank);
}
Conscript* BinarySearchTree::Search(int rank) //Пошук
{
    auto* node = RecursiveSearch(root, rank);
    if (node == nullptr)
        return nullptr;
    return node->data;
}
void BinarySearchTree::Insert(Conscript* data) //Заповнення контейнера
{
    RecursiveInsert(root, data);
}
void BinarySearchTree::RecursiveInsert(Node*& node, Conscript* data) {
    if (node == nullptr) {
        node = new Node(data);
    }
    else {
        if (data->getRank() < node->data->getRank())
            RecursiveInsert(node->left, data);
        else
            RecursiveInsert(node->right, data);
    }
}

void BinarySearchTree::PrintInorder(Node* node) //Функція, що виводить інформацію, що міститься у дереві на екран
{
    if (node == nullptr)
        return;
    PrintInorder(node->left);
    node->data->show();
    cout << endl;
    PrintInorder(node->right);
}

void BinarySearchTree::PrintTree() {
    PrintInorder(root);
}
void BinarySearchTree::PrintInorderCadet(Node* node)  //Функція що виводить лише кадетів
{
    if (node == nullptr)
        return;
    PrintInorderCadet(node->left);
    if (dynamic_cast<Cadet*>(node->data) != nullptr)
    {
        node->data->show();
        cout << endl;
    }
    PrintInorderCadet(node->right);
}
void BinarySearchTree::PrintChildrenByRank(int rank) {
    auto* node = RecursiveSearch(root, rank);
    if (dynamic_cast<Captain*>(node->data) != nullptr)        //Перевірка чи відповідає заданий ранг капітану
    {
        PrintInorderCadet(node);
        return;
    }
    cout << "This is not captain." << endl;
}

BinarySearchTree::~BinarySearchTree() //Деструктор викликає функцію для видалення даних з дерева
{
    CleanTree(root);
}
void BinarySearchTree::CleanTree(Node* node) {
    if (node == nullptr) return;
    CleanTree(node->left);
    CleanTree(node->right);

    delete node;
}

void BinarySearchTree::LoadFromFile() //Функція зчитування з файлу
{
    string flName;
    cout << "File name:" << endl;
    cin >> flName;
    ifstream in(flName);
    try                        //Обробка вийнятків
    {
        if (!in.is_open())
        {
            throw exception();
        }
        Cadet* cadetObj;
        Captain* captainObj;
        int info;
        in >> info;
        while (!in.eof())
        {
            if (info == 1)
            {
                cadetObj = new Cadet();
                in >> (*cadetObj);
                Insert(cadetObj);
            }
            if (info == 2)
            {
                captainObj = new Captain();
                in >> (*captainObj);
                Insert(captainObj);
            }
            in >> info;
        }
        cout << "Information loaded from file" << endl;
    }
    catch (const std::exception&e)
    {
        cout << "Error of open..." << endl;
    }
    in.close();
};

void BinarySearchTree::LoadIntoFile() //Функція запису інформації у файл
{
    if (root == nullptr)
    {
        cout << "There is no data in tree" << endl;
        return;
    }
    ofstream out("Output.txt");
    if (!out.is_open())
    {
        cout << "Error of open..." << endl;
        return;
    }
    LoadIntoFileRecursively(root, out);
    out.close();
}
void BinarySearchTree::LoadIntoFileRecursively(Node* nextNode, ofstream& out) {
    if (!nextNode)
       return;
    else
    {
        if (dynamic_cast<Cadet*>(nextNode->data) != nullptr)
        {
            out << 1 << '\n';
            out << *((Cadet*)(nextNode->data));
        }
        if (dynamic_cast<Captain*>(nextNode->data) != nullptr)
        {
            out << 2 << '\n';
            out << *((Captain*)(nextNode->data));
        }
        cout << "Information saved in file" << endl;
        LoadIntoFileRecursively(nextNode->left, out);
        LoadIntoFileRecursively(nextNode->right, out);
    }
      }
      

    ДОДАТОК Г

Рис.3 Діаграма об’єктів для тестування у нотації UML
     

    ДОДАТОК Д
#define BOOST_TEST_MAIN
#define BOOST_TEST_DYN_LINK
#include <boost/test/unit_test.hpp>
#include "binarySearchTree.h"
#include "captain.h"
#include "cadet.h"

// Для виконання тесту назва функції main була змінена на new_main

BOOST_AUTO_TEST_SUITE(InsertTest)

BOOST_AUTO_TEST_CASE(InsertCaptainObject)
{
	cout << endl;
	BinarySearchTree* tree;
	tree = new BinarySearchTree();
	Captain* Node;
	Node = new Captain("Sydorov", "Sidr", 15, 30, 4);
	tree->Insert(Node);
	tree->PrintTree();
	delete tree;
}

BOOST_AUTO_TEST_CASE(InsertCadetObject)
{
	BinarySearchTree* tree;
	tree = new BinarySearchTree();
	Cadet* Node;
	Node = new Cadet("Ivanov", "Ivan", 8, 22, "2_polk");
	tree->Insert(Node);
	tree->PrintTree();
	delete tree;
}

      BOOST_AUTO_TEST_SUITE_END()

     
     28
     
